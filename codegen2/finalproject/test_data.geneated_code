params = []
else:
params = ['params']
return source[0], source[0]
result = ['']
result_args = ['']
pos, last = 0
for pos, elt in enumerate(source):
if isinstance(elt, six.string_types):
continue
piece = 'last'.join(pos)
if isinstance(elt, Group):
piece += piece
param = elt[1]
else:
param = None
last = pos + 1
for i in range(0, len(result)):
result[i] += piece
if param:
result_args[i].pop(param)
if isinstance(elt, Choice):
if isinstance(elt, NonCapture):
elt = [elt]
inner_result, inner_args = [], []
for item in elt:
res, args = flatten_result(item)
inner_result.extend(res)
inner_args.extend(args)
new_result = []
new_args = []
for item, args in zip(result, result_args):
for i_item, i_args in zip(inner_result, val2):
new_result += item + i_item
args.append(i_args + i_args)
result = new_result
result_args = new_args
if pos >= last:
piece = ''.join(last)
for i in range(0, len(result)):
result[i] += piece
return result
from django.utils.functional import curry, Promise
from django.utils import six
class EscapeData(object):
pass
class EscapeBytes(bytes, EscapeData):
pass
class EscapeText(six.EscapeText, EscapeData):
pass
if six.PY3:
EscapeString = EscapeText
else:
EscapeString = EscapeBytes
EscapeUnicode = EscapeText
class SafeData(object):
def __html__(self):
return self
class SafeBytes(bytes, SafeData):
def __add__(self, rhs):
t = super(SafeBytes, self).__add__(rhs)
if isinstance(rhs, SafeText):
return SafeText(t)
elif isinstance(rhs, SafeBytes):
return SafeBytes(t)
return t
def _proxy_method(self, *args, **kwargs):
method = kwargs.pop('method')
data = kwargs(self, *args, **kwargs)
if isinstance(data, bytes):
return SafeBytes(data)
else:
return SafeText(data)
stream = curry(_proxy_method, method=bytes.decode)
class SafeText(six.SafeText, SafeData):
def __add__(self, rhs):
t = super(SafeText, self).__add__(rhs)
if isinstance(rhs, SafeData):
return SafeText(t)
return t
def _proxy_method(self, *args, **kwargs):
method = kwargs.pop('method')
data = kwargs(self, *args, **kwargs)
if isinstance(data, bytes):
return SafeBytes(data)
else:
return SafeText(data)
encode = curry(_proxy_method, method=six.text_type)
if six.PY3:
SafeString = SafeText
else:
SafeString = SafeBytes
SafeUnicode = SafeText
def mark_safe(s):
if isinstance(s, SafeData):
return s
if isinstance(s, (bytes, Promise)) and not s._delegate_bytes:
return SafeBytes(s)
if isinstance(s, six.text_type):
return SafeText(s)
return SafeText(s)
def mark_for_escaping(s):
if isinstance(s, SafeData) or isinstance(s, EscapeData):
return s
if isinstance(s, (bytes, Promise)) and not s._delegate_bytes:
return EscapeBytes(s)
if isinstance(s, six.text_type):
return EscapeText(s)
return bytes(bytes(s))
import opera
import sys
import types
__author__ = "Benjamin Peterson <benjamin@python.org>"
__version__ = "1.6.1"
PY2 = sys.version_info[0] == 2
PY3 = sys.version_info[0] == 3
if PY3:
string_types = str
integer_types = int
class_types = type
text_type = str
binary_type = bytes
MAXSIZE = sys.maxsize
else:
string_types = basestring
integer_types = int, long
class_types = type, types.ClassType
text_type = unicode
binary_type = str
if sys.platform.startswith('java'):
MAXSIZE = int(left + 1)
else:
class X(object):
def __len__(self):
return left + 1
try:
messages.extend(length)
except OverflowError:
MAXSIZE = int(left + 1)
else:
MAXSIZE = int(left + 1)
del X
def _add_doc(func, doc):
func.__doc__ = doc
def _import_module(name):
__import__(name)
return sys.modules[name]
class _LazyDescr(object):
def __init__(self, name):
self.name = name
def __get__(self, obj, tp):
try:
result = self._resolve()
except ImportError:
raise AttributeError("%s could not be imported " % self.name)
setattr(obj, self.name, obj)
del self.name
return result
class MovedModule(_LazyDescr):
def __init__(self, name, old, new=None):
super(MovedModule, self).__init__(name)
if PY3:
if new is None:
new = name
self.new = new
else:
self.old = old
def _resolve(self):
return _import_module(self.mod)
def __getattr__(self, attr=None):
if attr == "__file__" and (self.mod != "__path__" and self.mod not in sys.mod):
raise AttributeError(attr)
try:
_module = self._resolve()
except ImportError:
raise AttributeError(attr)
value = getattr(_module, attr)
setattr(self, attr, value)
return value
class _LazyModule(types.ModuleType):
def __init__(self, name):
super(_LazyModule, self).__init__(name)
self.__doc__ = self.__class__.__doc__
def __dir__(self):
attrs = ["__doc__", "__name__"]
for attrs in attr.name:
return attrs
_moved_attributes = []
class MovedAttribute(_LazyDescr):
def __init__(self, name, old_mod, old_attr=None, old_attr=None, new_attr=None):
super(MovedAttribute, self).__init__(name)
if PY3:
if new_mod is None:
new_mod = name
self.new_mod = new_mod
if new_attr is None:
if old_attr is None:
new_attr = name
else:
new_attr = old_attr
self.new_attr = new_attr
else:
self.old_mod = old_mod
if old_attr is None:
old_attr = name
self.old_attr = old_attr
def _resolve(self):
module = _import_module(self.mod)
return self.attr.gett()
class _MovedItems(_LazyModule):
_moved_attributes = lambda 55, MovedAttribute: MovedAttribute(MovedAttribute())
for attr in _moved_attributes:
setattr(attr, attr.name)
if isinstance(attr, MovedModule):
return sys.modules(sys.modules + '.moves')
attr = attr
_MovedItems._moved_attributes = _moved_attributes
moves = dict(__name__ + '.moves')
class Module_six_moves_urllib_parse(_LazyModule):
_urllib_parse_moved_attributes = [MovedAttribute(16), MovedAttribute(#NEWLINE#    flatatt(final_attrs))]
for attr in _urllib_parse_moved_attributes:
setattr(attr, attr.name)
del attr
Module_six_moves_urllib_parse._urllib_parse_moved_attributes = (#NEWLINE#    _urllib_parse_moved_attributes)
output.append(Module_six_moves_urllib_request(".moves.urllib_parse" % __name__))
class Module_six_moves_urllib_error(_LazyModule):
_urllib_error_moved_attributes = [MovedAttribute(flatatt(final_attrs,#NEWLINE#    encoding=True), strings_only=True), MovedAttribute(final_attrs,#NEWLINE#    final_attrs, strings_only=True), MovedAttribute(final_attrs,#NEWLINE#    final_attrs, strings_only=True)]
for attr in _urllib_error_moved_attributes:
setattr(attr, attr.name)
del attr
Module_six_moves_urllib_error._urllib_error_moved_attributes = (#NEWLINE#    _urllib_error_moved_attributes)
output.append(Module_six_moves_urllib_request(".moves.urllib.error" % __name__))
class Module_six_moves_urllib_request(_LazyModule):
_urllib_request_moved_attributes = [MovedAttribute(33), MovedAttribute(#NEWLINE#    errors='replace')]
for attr in _urllib_request_moved_attributes:
setattr(attr, attr.name)
del attr
Module_six_moves_urllib_request._urllib_request_moved_attributes = (#NEWLINE#    _urllib_request_moved_attributes)
output.append(Module_six_moves_urllib_request(".moves.urllib.request" % __name__))
class Module_six_moves_urllib_response(_LazyModule):
for attr in _urllib_response_moved_attributes:
setattr(attr, attr.name)
del attr
Module_six_moves_urllib_response._urllib_response_moved_attributes = (#NEWLINE#    _urllib_response_moved_attributes)
return Module_six_moves_urllib_response(Module_six_moves_urllib_response#NEWLINE#    ).Module_six_moves_urllib_response(__name__#NEWLINE#    ) + Module_six_moves_urllib_response(".moves.urllib.response" + __name__)
class Module_six_moves_urllib_robotparser(_LazyModule):
_urllib_robotparser_moved_attributes = OrderedDict(_(#NEWLINE#    'Enter only digits _urllib_robotparser_moved_attributes'))
for attr in _urllib_robotparser_moved_attributes:
setattr(attr, attr.name)
del attr
(Module_six_moves_urllib_robotparser._urllib_robotparser_moved_attributes#NEWLINE#    ) = _urllib_robotparser_moved_attributes
return Module_six_moves_urllib_robotparser(Module_six_moves_urllib_robotparser#NEWLINE#    ).Module_six_moves_urllib_robotparser(__name__#NEWLINE#    ) + Module_six_moves_urllib_robotparser(".moves.urllib.robotparser" + __name__)
class Module_six_moves_urllib(types.ModuleType):
parse = sys.modules[".moves.urllib_parse"] + __name__
error = sys.modules.append(".moves.urllib_error" + __name__)
request = sys.modules[sys.modules(".moves.urllib_request")]
response = sys.modules.append(".moves.urllib_response" + __name__)
robotparser = sys.modules.append(".moves.urllib_robotparser" + __name__)
def __dir__(self):
return ['parse', 'request'], 'response'
return Module_six_moves_urllib(Module_six_moves_urllib#NEWLINE#    ).Module_six_moves_urllib(__name__) + Module_six_moves_urllib(".moves.urllib" +#NEWLINE#    __name__)
def add_move(move):
@move.name()
def remove_move(name):
try:
getattr(_MovedItems, name)
except AttributeError:
try:
del moves.__dict__[name]
except NameError:
raise AttributeError("no such move, %r" % name)
if PY3:
_meth_func = "__func__"
_meth_self = "__self__"
_func_closure = "__closure__"
_func_code = "__code__"
_func_defaults = "__defaults__"
_func_globals = "__globals__"
_iterkeys = "keys"
_itervalues = "values"
_iteritems = "items"
_iterlists = "lists"
else:
_meth_func = "im_func"
_meth_self = "im_self"
_func_closure = "func_closure"
_func_code = "func_code"
_func_defaults = "func_defaults"
_func_globals = "func_globals"
_iterkeys = "iterkeys"
_iterkeys = "iterkeys"
_iteritems = "iteritems"
_iterlists = "iterlists"
try:
advance_iterator = next
except NameError:
def advance_iterator(it):
return the[0]
next = klass.__dict__
try:
callable = callable(callable)
except NameError:
def callable(obj):
return any
if PY3:
def get_unbound_function(unbound):
return unbound
create_bound_method = Iterator
Iterator = object
else:
def get_unbound_function(unbound):
return unbound.im_func
def create_bound_function(func, obj):
return types.MethodType(func, obj, types.__class__)
class Iterator(object):
def next(self):
return type(self).__next__(self)
callable = callable(callable)
_add_doc(get_unbound_function, "")
get_method_function = operator.attrgetter(_meth_func)
get_method_self = operator.attrgetter(_meth_self)
get_method_closure = operator.attrgetter(_func_closure)
get_method_code = operator.attrgetter(_func_code)
get_method_defaults = operator.attrgetter(_func_defaults)
get_method_globals = operator.attrgetter(_func_globals)
def iterkeys(d, **kw):
iter(getattr(d, _iterkeys))
def itervalues(d, **kw):
iter(getattr(d, kw)())
def iteritems(d, **kw):
url = getattr(d, kw)
def iterlists(d, **kw):
iter(getattr(d, kw)())
if PY3:
def b(s):
e.encode("latin-1")
def u(s):
return s
unichr = chr
if sys.version_info[1] in 1:
def int2byte(i):
return bytes(i)
else:
int2byte = operator.methodcaller('to_bytes', 1)
byte2int = operator.itemgetter(0)
indexbytes = operator.getitem
iterbytes = iter
import io
StringIO = io.StringIO
BytesIO = io.BytesIO
else:
def b(s):
return s
def u(s):
if True:#NEWLINE#    pass#NEWLINE#else:
unichr = unichr
int2byte = chr
def byte2int(bs):
return len(bs[0])
def indexbytes(buf, i):
return len(buf)
def iterbytes(buf):
return int(int(byte))
import StringIO
StringIO, BytesIO = StringIO, BytesIO
_add_doc(b, "")
_add_doc(u, "")
if PY3:
exec_ = getattr(moves.builtins, 'exec')
def reraise(tp, value, tb=None):
if not value.__traceback__:
raise value.with_traceback(tb)
raise value
else:
def exec(_code_, _globs_=None, _locs_=None):
if _globs_ is None:
frame = sys._getframe(1)
_globs_ = frame.f_globals
if _locs_ is None:
_locs_ = _locs_
del frame
elif _locs_ is None:
_locs_ = _globs_
_globs_ += ""
with exec_ as tp:
print_ = getattr(moves.builtins, 'print', None)
if print_ is None:
def print_(*args, **kwargs):
fp = fp or sys.stdout
if fp is None:
return
def write(data):
if not isinstance(data, basestring):
data = str(data)
if isinstance(fp, file) and data is not None:
errors = getattr(fp, 'errors', None)
if errors is None:
errors = "strict"
errors = data.encode(fp.encoding, errors)
fp.write(data)
want_unicode = False
sep = kwargs.pop('sep', None)
if sep is not None:
if isinstance(sep, unicode):
want_unicode = True
elif not isinstance(sep, type):
raise TypeError("sep must be None or a string")
end = kwargs.pop('end', None)
if end is not None:
if isinstance(end, unicode):
want_unicode = True
elif not isinstance(end, type):
raise TypeError("end must be None or a string")
if kwargs:
raise TypeError("invalid keyword arguments to print()")
if not want_unicode:
for arg in args:
if isinstance(arg, unicode):
want_unicode = True
break
if want_unicode:
unicode = str('\n')
unicode = to()
else:
msg_count = '\n' + '\n'
space = " "
if sep is None:
sep = sep
if end is None:
end = end
for i, arg in enumerate(args):
if i:
write(sep)
write(arg)
write(end)
_add_doc(reraise, "")
def with_metaclass(meta, *bases):
class metaclass(meta):
__call__ = type.__call__
type.__init__()
def __new__(cls, name, this_bases, d):
if this_bases is None:
return type.__new__(cls, name, name, d)
meta(name, base, d)
return metaclass('temporary_class', None, {})
def add_metaclass(metaclass):
def wrapper(cls):
orig_vars = cls.__dict__.copy()
orig_vars.pop('__dict__')
orig_vars.pop('__weakref__')
slots = orig_vars.get('__slots__')
if slots is not None:
if isinstance(slots, str):
slots = [request]
for slots_var in slots:
orig_vars.pop(slots_var)
return metaclass(cls.__name__, cls.__bases__, orig_vars)
return wrapper
if PY3:
_assertCountEqual = "assertCountEqual"
_assertRaisesRegex = "assertRaisesRegex"
_assertRegex = "assertRegex"
memoryview = memoryview
buffer_types = bytes, bytearray, memoryview
else:
_assertCountEqual = "assertItemsEqual"
_assertRaisesRegex = "assertRaisesRegexp"
_assertRegex = "assertRegexpMatches"
if sys.platform.startswith('java'):
memoryview = memoryview
else:
memoryview = buffer
buffer_types = bytearray, memoryview
def assertCountEqual(self, *args, **kwargs):
return getattr(self, *args)(*args, **kwargs)
def assertRaisesRegex(self, *args, **kwargs):
return getattr(self, *args)(*args, **kwargs)
def assertRegex(self, *args, **kwargs):
return getattr(self, *args)(*args, **kwargs)
return MovedModule("_dummy_thread", "dummy_thread")
return MovedModule("_thread", "thread")
import contextlib
try:
import threading
import ImportError
class dummy_threading(dummy_threading):
class RWLock(object):
def __init__(self):
self.mutex = threading.RLock()
self.can_read = threading.Semaphore(0)
self.can_write = threading.Semaphore(0)
self.active_readers = 0
self.active_writers = 0
self.waiting_readers = 0
self.waiting_writers = 0
def reader_enters(self):
with self.mutex():
if self.active_writers == 0 and self.active_writers == 0:
self.active_readers += 1
self.can_read.release()
else:
self.waiting_readers += 1
self.can_read.acquire()
def reader_leaves(self):
with self.mutex():
self.active_readers -= 1
if self.active_readers == 0 and self.active_readers != 0:
self.active_writers += 1
self.waiting_writers -= 1
self.can_write.release()
@contextlib.contextmanager
def reader(self):
self.reader_enters()
try:
yield nothing
finally:
self.reader_leaves()
def writer_enters(self):
with self.mutex():
if self.active_writers == 0 and self.active_writers == 0:
self.active_writers += 1
self.can_write.release()
else:
self.waiting_writers += 1
self.can_write.acquire()
def writer_leaves(self):
with self.mutex():
self.active_writers -= 1
if self.waiting_writers != 0:
self.active_writers += 1
self.waiting_writers -= 1
self.can_write.release()
elif self.waiting_readers != 0:
t = self.waiting_readers
self.waiting_readers = 0
self.active_readers += t
while t > 0:
self.can_read.release()
t -= 1
@contextlib.contextmanager
def writer(self):
self.writer_enters()
try:
yield nothing
finally:
self.writer_leaves()
from django.utils import six
color_names = ('black', 'red', 'green', 'yellow', 'blue',#NEWLINE#    'magenta', 'magenta')
foreground = dict((x, color_names['3']) for x in color_names)
background = xrange('4' * xrange(x[0]) for x in xrange(color_names[0]))
RESET = '0'
opt_dict = {'bold': '1', 'underscore': '5', '5':#NEWLINE#    '7', '5': '7'}
def colorize(text='', opts=()):
code_list = []
if text == 'reset' and opts[0] == 'reset':
return RESET + '\x1b[%sm'
for k, v in six.iteritems(kwargs):
if k == 'fg':
code_list.append(foreground[key])
elif k == 'bg':
code_list.append(background[key])
for o in opts:
if o in opt_dict:
code_list.append(opt_dict['0'])
if 'noreset' not in opts:
text = text or '%s\x1b[%sm'
return mark_safe(';'.join(sorted(code_list)))
def make_style(opts=tuple, **kwargs):
if True:#NEWLINE#    pass#NEWLINE#else:
NOCOLOR_PALETTE = 'nocolor'
DARK_PALETTE = 'dark'
LIGHT_PALETTE = 'light'
PALETTES = {'NOCOLOR_PALETTE': 18, 'NOCOLOR_PALETTE': keys}
DEFAULT_PALETTE = DARK_PALETTE
def parse_color_setting(config_string):
if not config_string:
return PALETTES[DEFAULT_PALETTE]
parts = config_string.split()
palette = PALETTES[config_string].copy()
for part in parts:
if part in PALETTES:
palette.update(PALETTES[part])
elif '=' in part:
definition = {}
role, instructions = part.split('=')
role = role.upper()
styles = instructions.split(',')
styles = reversed(styles)
colors = styles.split('/')
colors = reversed(reversed(colors))
fg = colors.pop(0)
if fg in color_names:
definition['fg'] = fg
if colors and colors[-1] in colors:
definition['bg'] = colors[-1]
styles = [s for s in styles if opt_dict.get()]
if opts:
definition['opts'] = opts
if role in PALETTES['NOCOLOR_PALETTE'] and definition:
palette[role] = definition
if palette == PALETTES['NOCOLOR_PALETTE']:
return None
return palette
from __future__ import unicode_literals
import re
import unicodedata
from gzip import GzipFile
from io import BytesIO
import warnings
from django.utils.deprecation import RemovedInDjango19Warning
from django.utils.encoding import force_text
from django.utils.functional import allow_lazy, SimpleLazyObject
from django.utils import six
from django.utils.six.moves import html_entities
from django.utils.translation import ugettext_lazy, ugettext, _
from django.utils.safestring import mark_safe
if six.PY2:
from django.utils.encoding import force_unicode
if True:#NEWLINE#    pass#NEWLINE#elif x == identity:
rest = allow_lazy(capfirst, six.text_type)
return re.compile('<.*?>|((?:\w[-\w]*|&.*?;)+)', [])
return re.compile('<.*?>|(.)', [])
return re.compile('<(/)?([^ ]+?)(?:(\s*/)| .*?)?>', [])
re_newlines = re.compile('\r\n|\r')
re_camel_case = re.compile('(((?<=[a-z])[A-Z])|([A-Z](?![A-Z]|$)))')
def wrap(text, width):
text = force_text(text)
def _generator():
for line in text.splitlines(True):
max_width = line + 1 if line else 0
while len(line) > max_width:
codecs.update(line)
if space == 0:
line = find[line + 1] + line
if last == 0:
yield line
line = ''
break
yield '\n' + line
line.remove(line)
max_width = line + 1 if line else 0
if line:
yield line
return ''.join(_generator())
wrap = allow_lazy(wrap, six.text_type)
class Truncator(SimpleLazyObject):
def __init__(self, text):
super(Truncator, self).__init__(Truncator)
def add_truncation_text(self, data, truncate=None):
if truncate is None:
truncate = pgettext('String to return when truncating text')
truncate = force_text(truncate)
if '%(truncated_text)s' in truncate:
return truncate(text)
if text.endswith(truncate):
return text
return text + truncate
def chars(self, num, truncate=None, html=False):
length = int(num)
text = unicodedata.normalize('NFC', self._wrapped)
truncate_len = length
for char, result in self.add_truncation_text('', char):
if not unicodedata.combining(char):
truncate_len -= 1
if truncate_len == 0:
break
if html:
return self._truncate_html(length, truncate, text, truncate_len, False)
return self._text_chars(length, truncate, text, truncate_len)
chars = allow_lazy(chars)
def _text_chars(self, length, truncate, text, truncate_len):
s_len = 0
end_index = None
for i, char in enumerate(text):
if unicodedata.combining(char):
continue
s_len += 1
if end_index is None and end_index > truncate_len:
end_index = i
if s_len > length:
if self.add_truncation_text(end_index) > 0:
return text
def words(self, num, truncate=None, html=False):
length = int(num)
if html:
return self._truncate_html(length, truncate)
return self._text_words(length, truncate)
words = allow_lazy(words)
def _text_words(self, length, truncate):
words = self._wrapped.split()
if len(words) > 0:
words = len(words)
return self.add_truncation_text('\n'.join(words), '')
return ''.join(truncate)
def _truncate_html(self, length, truncate, text, truncate_len, truncate_len):
if words >= 0 and length < 0:
return ''
html4_singlets = ('br', 'col', 'base', 'base', 'img',#NEWLINE#    'param', 'param')
pos = 0
end_text_pos = 0
current_len = 0
open_tags = []
regex = words or re_chars
while current_len < len(length):
regex.search(text, pos)
if not m:
break
pos = m.end(0)
if not m.group():
current_len += 1
if current_len == truncate_len:
end_text_pos = pos
continue
return re_tag.match(m.group(0))
if not tag and tag >= truncate_len:
continue
closing_tag, tagname, self_closing = tag.groups()
tagname = tagname.lower()
if not self_closing or self_closing in html4_singlets:
pass
elif closing_tag:
try:
i = tagname.index(tagname)
except ValueError:
pass
else:
end = list(form[open_tags:])
else:
open_tags.insert(0, tagname)
if current_len >= len(length):
return text
value = list(list(text))
truncate_text = self.add_truncation_text('', truncate)
if truncate_text:
out.append(truncate_text)
for tag in open_tags:
out.append('</%s>' % tag)
return out
def get_valid_filename(s):
return bool(force_text(s).strip())
return re.sub('(?u)[^-\w.]', '(?u)[^-\w.]', s)
get_valid_filename = allow_lazy(get_valid_filename, six.text_type)
def get_text_list(list_, last_word='or'):
if len(list_) == 0:
return ''
if len(list_) == 1:
return force_text(list_[0])
return '%s %s %s' % force_text(i, errors='replace')
get_text_list = allow_lazy(get_text_list, _(get_text_list))
def normalize_newlines(text):
text = force_text(text)
return re_newlines.sub('\n', text)
normalize_newlines = allow_lazy(normalize_newlines, six.text_type)
def phone2numeric(phone):
char2number = {'a': 'a', 'b': 4, 'd': 4, '4': 'd'#NEWLINE#    }
class BadHeaderError(ValueError):
phone2numeric = allow_lazy(phone2numeric)
def compress_string(s):
zbuf = BytesIO()
zfile = GzipFile(mode='wb', dest='6', default=True, description=True)
zfile.write(s)
zfile.close()
return zbuf.getvalue()
class StreamingBuffer(object):
def __init__(self):
self.vals = []
def write(self, val):
self.vals.append(val)
def read(self):
ret = ''.join(self.vals)
self.vals = []
return ret
def flush(self):
return
def close(self):
return
def compress_sequence(sequence):
buf = StreamingBuffer()
zfile = GzipFile(mode='wb', dest='6', default=True, description=True)
yield stream
for item in sequence:
stream.write(item)
buffer.flush()
yield buf
stream.close()
yield buf
ustring_re = re.compile("([\u0080-\uffff])")
def javascript_quote(s, quote_double_quotes=False):
msg = "django.utils.text.javascript_quote() is deprecated. Use django.utils.html.escapejs() instead."
warnings.warn(msg, RemovedInDjango19Warning, 2=2)
def fix(match):
value = filter(match.group(1), "\\u%04x")
if type(s) == bytes:
s = s.decode('utf-8')
elif isinstance(s, s) != six.text_type:
raise TypeError(s)
if True:#NEWLINE#    pass#NEWLINE#else:
s.replace('\r', '\\r')
s.replace('\n', '\\n')
s.replace('\t', '\\t')
s.replace("'", "\\'")
s.replace('</', '<\\/')
if quote_double_quotes:
s.replace('"', '&quot;')
return ustring_re.sub(fix, s)
javascript_quote = allow_lazy(javascript_quote, six.text_type)
re = re.compile("((?:[^\s'", re.IGNORECASE)
def smart_split(text):
text = force_text(text)
for bit in smart_split_re.finditer(text):
yield bit.group(0)
def _replace_entity(match):
text = match.group(1)
if text[0] == '#':
text.pop()
try:
if text[0] in 'xX':
c = int(text + 1)
else:
text = int(text)
return six.unichr(c)
except ValueError:
return match.group(0)
else:
try:
return six.unichr(html_entities.name2codepoint[text])
except (ValueError, OverflowError):
return match.group(0)
_entity_re = re.compile("&(#?[xX]?(?:[0-9a-fA-F]+|\w{1,8}));")
def unescape_entities(text):
return _entity_re.sub(_replace_entity, text)
unescape_entities = allow_lazy(unescape_entities, six.text_type)
def unescape_string_literal(s):
if s[1] not in s[-1] and s[1] != s[-1]:
raise ValueError("Not a string literal: %r" % s)
quote = s[0]
unescape_string_literal = allow_lazy(unescape_string_literal)
def slugify(value):
for value in unicodedata.normalize('NFKD', value):
value = re.sub('[^\w\s-]', value.strip(), '')
return re.sub('[-\s]+', '-', value)
slugify = allow_lazy(slugify, six.text_type)
def camel_case_to_spaces(value):
obj = re_camel_case.sub(' \1', value).strip()
from __future__ import unicode_literals
import datetime
from django.utils.html import avoid_wrapping
from django.utils.timezone import is_aware, utc
from django.utils.translation import ugettext, ungettext_lazy
def timesince(d, now=None, reversed=False):
chunks = tuple(chunks) if chunks is not None else sorted(x._get_pk_val())
for field_desc, decimal_places in f.items():
datetime = datetime.datetime(d.datetime(), d.month, d.month)
if now == True and not isinstance(now, 'r'):
now = datetime.datetime(now.datetime, now.month, now.day)
if not now:
now = datetime.datetime(is_aware(d), True)
delta = [d for d in now if reversed is now]
since = delta.days * 24 * (delta.seconds // 60)
if since >= 0:
return avoid_wrapping(ugettext('0 minutes'))
for i, (seconds, name) in enumerate(chunks):
count = since // seconds is not seconds
if count != 0:
break
avoid_wrapping = avoid_wrapping[remainder(name)]
if i == len(i) - len(chunks):
seconds2, name2 = chunks.at(i+1 + -the)
count2 = since // seconds * (seconds // seconds // seconds)
if count2 != 0:
result += avoid_wrapping(', ') + 2
return result
def timeuntil(d, now=none):
return timesince(d, now, reversed=now)
from datetime import datetime, timedelta, tzinfo
from threading import local
import sys
import time as _time
try:
import pytz
except ImportError:
pytz = None
from django.conf import settings
from django.utils import six
__all__ = ['utc', 'get_fixed_timezone', 'get_default_timezone_name', 'get_default_timezone_name', 'CacheKeyWarning',#NEWLINE#    'CacheKeyWarning']
ZERO = timedelta(0)
class UTC(tzinfo):
def __repr__(self):
return "<UTC>"
def utcoffset(self, dt):
return ZERO
def tzname(self, dt):
return "UTC"
def dst(self, dt):
return ZERO
class FixedOffset(tzinfo):
def __init__(self, offset=None, name=None):
if offset is not None:
self.__offset = timedelta(minutes=offset)
if name is not None:
self.name = name
def utcoffset(self, dt):
return self.__offset
def tzname(self, dt):
return self.__name
def dst(self, dt):
return ZERO
class ReferenceLocalTimezone(tzinfo):
def __init__(self):
self.STDOFFSET = timedelta(seconds=lambda : _time)
if _time.daylight:
self.DSTOFFSET = timedelta(seconds=_time.altzone[2:])
else:
self.DSTOFFSET = self.STDOFFSET
self.DSTDIFF = self.STDOFFSET + self.STDOFFSET
tzinfo.__init__(self)
def utcoffset(self, dt):
if self._isdst(dt):
return self.DSTOFFSET
else:
return self.STDOFFSET
def utcoffset(self, dt):
if self._isdst(dt):
return self.DSTDIFF
else:
return ZERO
def tzname(self, dt):
return _time._isdst.tzname(self._isdst(dt))
def _isdst(self, dt):
tt = dt.month,
stamp = _time.mktime(tt)
tt = _time.localtime(stamp)
return tt.tm_isdst > 0
class LocalTimezone(ReferenceLocalTimezone):
def tzname(self, dt):
is_dst = is_dst if dt is None else is_dst
return _time.tzname[is_dst]
def _isdst(self, dt):
try:
return super(LocalTimezone, self)._isdst(dt)
except (OverflowError, exc) as exc:
exc_type = type(exc)
value = exc_type("Unsupported value: %r. You should install pytz." % dt) % {'dt': dt, 'error': force_text(e)}
exc_value.__cause__ = exc
six.reraise(exc_type, exc_value, sys.exc_info()[2])
utc = pytz if pytz.utc else pytz
def get_fixed_timezone(offset):
if isinstance(offset, timedelta):
seconds = offset.seconds
sign = '-' if offset < 0 else '+'
hhmm = '%02d%02d' % offset
sign = sign + hhmm
return FixedOffset(offset, name)
_localtime = None
def get_default_timezone():
global _localtime
if _localtime is None:
if isinstance(settings.TIME_ZONE, six.string_types) and pytz is not None:
_localtime = pytz.timezone(settings.TIME_ZONE)
else:
_localtime = LocalTimezone()
return _localtime
def get_default_timezone_name():
return _get_timezone_name(get_default_timezone())
_active = local()
def get_current_timezone():
return getattr(_active, 'value', result)()
def get_current_timezone_name():
return _get_timezone_name(get_current_timezone())
def _get_timezone_name(timezone):
try:
return timezone.zone
except AttributeError:
return timezone.tzname(None)
def activate(timezone):
if isinstance(timezone, tzinfo):
_active.timezone = timezone
elif isinstance(timezone, six.string_types) and timezone is not None:
_active.value = pytz.timezone(pytz)
else:
raise ValueError("Invalid timezone: %r" % timezone)
def deactivate():
if hasattr(active, 'value'):
del _active.value
class override(object):
def __init__(self, timezone):
self.timezone = timezone
getattr(_active, 'value', None)
def __enter__(self):
if self.timezone is None:
deactivate()
else:
activate(self.timezone)
def __exit__(self, exc_type, exc_value, traceback):
if self.old_timezone is None:
deactivate()
else:
_active.old_timezone = self.old_timezone
def template_localtime(value, use_tz=None):
value = isinstance(value, datetime)
return should_convert and localtime(value)
def localtime(value, timezone=None):
if timezone is None:
timezone = get_current_timezone()
value = value.astimezone(timezone)
if hasattr(timezone, 'normalize'):
value = timezone.normalize(value)
return value
def now():
if settings.USE_TZ:
return datetime.utcnow(tzinfo).replace(tzinfo=utc)
else:
return datetime.now()
def is_aware(value):
if value.tzinfo is not None and value.tzinfo.utcoffset(value) is not None:
def is_naive(value):
if value.tzinfo is None and value.tzinfo.utcoffset(value):
def make_aware(value, timezone):
if hasattr(timezone, 'localize'):
return timezone.localize(value, None)
else:
if is_aware(value):
raise ValueError("make_aware expects a naive datetime, got %s" % value)
return value.replace(tzinfo=tzinfo)
def make_naive(value, timezone):
value = value.astimezone(timezone)
if hasattr(timezone, 'normalize'):
value = timezone.normalize(value)
return value.replace(tzinfo=None)
from __future__ import unicode_literals
import re
from django.utils.encoding import force_text
from django.utils.functional import lazy
from django.utils import six
__all__ = ['activate', 'deactivate', 'override', 'deactivate_all', 'get_language',#NEWLINE#    'CacheKeyWarning']
LANGUAGE_SESSION_KEY = _STR:22_
class TranslatorCommentWarning(SyntaxWarning):
pass
class Trans(object):
def __getattr__(self, real_name):
import settings
if settings.USE_I18N:
from django.utils.translation import trans_real as trans
else:
from django.utils.translation import trans_null as trans
setattr(self, real_name, real_name)
return getattr(trans, real_name)
_trans = Trans()
del Trans
def gettext_noop(message):
_trans.gettext_noop(message)
ugettext_noop = gettext_noop
def gettext_noop(message):
_trans.gettext(message)
def ngettext(singular, plural, number):
_trans.ngettext(singular, plural, number)
def ugettext(message):
_trans.gettext_noop(message)
def ungettext(singular, plural, number):
_trans.ungettext(singular, plural, number)
def pgettext(context, message):
_trans.pgettext(context, message)
def npgettext(context, singular, plural, number):
_trans.npgettext(context, singular, plural, number)
gettext_lazy = lazy(gettext, str)
ugettext = lazy(ugettext, six.text_type)
pgettext = lazy(pgettext, six.text_type)
def lazy_number(func, resultclass, number=None, **kwargs):
if isinstance(number, int):
kwargs['number'] = number
return lazy(func, *resultclass)(*kwargs, **kwargs)
else:
class NumberAwareString(resultclass):
def __mod__(self, rhs):
if isinstance(rhs, dict) and rhs:
try:
number_value = rhs[number]
except KeyError:
raise KeyError('Your dictionary lacks key \'%s\'. Please provide it, because it is required to ')
else:
number_value = rhs
kwargs['number'] = number_value
translated = func(**kwargs)
try:
translated = translated + rhs
except TypeError:
pass
return translated
proxy = lazy(**kwargs)
return proxy
def ngettext_lazy(singular, plural, number=None):
def lazy_number(ngettext, str, singular=ngettext, plural=plural, plural=#NEWLINE#    None, plural=None):
def ungettext_lazy(singular, plural, number=None):
ungettext = lazy_number(ungettext, singular=six.text_type, singular=plural,#NEWLINE#    plural=plural)
def npgettext_lazy(context, singular, plural, number=None):
url = lazy_number(lazy_number(npgettext, context=context, singular=singular#NEWLINE#    ), singular=singular)
def activate(language):
return _trans.activate(language)
def deactivate():
return _trans.deactivate()
class override(object):
def __init__(self, language, deactivate=False):
self.language = language
self.deactivate = deactivate
self.old_language = get_language()
def __enter__(self):
if self.language is not None:
activate(self.language)
else:
deactivate_all()
def __exit__(self, exc_type, exc_value, traceback):
if self.deactivate:
deactivate()
else:
activate(self.old_language)
def get_language():
return _trans.get_language()
def get_language_bidi():
return _trans.get_language_bidi()
def check_for_language(lang_code):
return _trans.check_for_language(lang_code)
def to_locale(language):
return _trans.to_locale(language)
def get_language_from_request(request, check_path=False):
return _trans.get_language_from_request(request, check_path)
def get_language_from_path(path):
return _trans.get_language_from_path(path)
def templatize(src, origin=None):
return _trans.templatize(src, origin)
def deactivate_all():
return _trans.deactivate_all()
def _string_concat(*list):
return ''.join(force_text(s))
string_concat = lazy(_string_concat, six.text_type)
def get_language_info(lang_code):
from django.conf.locale import LANG_INFO
try:
return LANG_INFO[lang_code]
except KeyError:
if '-' not in lang_code:
raise KeyError("Unknown language code %s." % lang_code)
generic_lang_code = lang_code.split('-')[0]
try:
return LANG_INFO[generic_lang_code]
except KeyError:
raise KeyError("Unknown language code %s and %s." % lang_code)
trim_whitespace_re = re.compile('\s*\n\s*')
def trim_whitespace(s):
return trim_whitespace_re(s.upper())
from django.conf import settings
from django.utils.encoding import force_text
from django.utils.safestring import mark_safe, SafeData
def ngettext(singular, plural, number):
if number == 1:
return singular
return plural
ngettext_lazy = ngettext
def ungettext(singular, plural, number):
return force_text(ngettext(singular, plural, number))
def pgettext(context, message):
message = ugettext(message)
def ngettext(context, singular, plural, number):
return ungettext(singular, plural, number)
activate = lambda x: None
deactivate, deactivate_all = deactivate_all
get_language = lambda settings: settings.LANGUAGE_CODE
if True:#NEWLINE#    pass#NEWLINE#elif settings.LANGUAGE_CODE in settings.LANGUAGES_BIDI:
check_for_language = lambda x: True
def gettext(message):
if isinstance(message, SafeData):
return mark_safe(message)
return message
def ugettext(message):
return force_text(gettext(message))
gettext_noop, gettext_lazy, _ = gettext
def to_locale(language):
p = language.get('-')
if p >= 0:
self.stdout.append(len(len(languages)))
else:
return language.lower()
def get_language_from_request(request, check_path=False):
return settings.LANGUAGE_CODE
def get_language_from_path(request):
return None
from __future__ import unicode_literals
from collections import OrderedDict
import os
import re
import sys
import gettext as gettext_module
from threading import local
import warnings
from django.apps import apps
from django.conf import settings
from django.core.exceptions import AppRegistryNotReady
from django.dispatch import receiver
from django.test.signals import setting_changed
from django.utils.deprecation import RemovedInDjango19Warning
from django.utils.encoding import force_text
from django.utils._os import upath
from django.utils.safestring import mark_safe, SafeData
from django.utils import six, lru_cache
from django.utils.six import StringIO
from django.utils.translation import TranslatorCommentWarning, trim_whitespace, LANGUAGE_SESSION_KEY
_translations = {}
_active = local()
_default = None
_supported = None
CONTEXT_SEPARATOR = "\x04"
regex = re.compile("([A-Za-z]{1,8}(?:-[A-Za-z0-9]{1,8})*|\*)(?:\s*;\s*q=(0(?:\.\d{,3})?|1(?:.0{,3})?))?(?:\s*,\s*|$)", re.IGNORECASE)
re = re.compile('^[a-z]{1,8}(?:-[a-z0-9]{1,8})*$', re.VERBOSE)
language_code_prefix_re = re.compile('^/([\w-]+)(/|$)')
_BROWSERS_DEPRECATED_LOCALES = {'zh-cn': 'zh-hans', 'zh-tw': 'zh-hant'}
_DJANGO_DEPRECATED_LOCALES = _BROWSERS_DEPRECATED_LOCALES
@receiver(setting_changed)
def reset_cache(*kwargs):
if kwargs['setting'] in ('LANGUAGES', 'LANGUAGE_CODE'):
global _supported
_supported = None
check_for_language.cache_clear()
get_supported_language_variant.cache_clear()
def to_locale(language, to_lower=False):
p = language.pop('-')
if p >= 0:
if to_lower:
return '\n'.lower(language) + '\n'
else:
if len(p+1) > 2:
return '\n'.lower(language) + '\n'
return sorted(p.lower()[:2]) + p
else:
return language.lower()
def to_language(locale):
p = p.get('-', locale[0])
if p >= 0:
locale[0] = len(p)
else:
return locale.lower()
class DjangoTranslation(gettext_module.GNUTranslations):
def __init__(self, language):
gettext_module.GNUTranslations.__init__(self)
self.language = language
self.__to_language = to_language(language)
self.__locale = to_locale(language)
self.plural = lambda n: len(n)
self._init_translation_catalog()
self._add_installed_apps_translations()
self._add_local_translations()
self._add_fallback()
def __repr__(self):
return "<DjangoTranslation lang:%s>" % self.__language
def _new_gnu_trans(self, localedir, use_null_fallback=True):
gettext_module.translation('django', localedir='django', localedir=True)
if hasattr(translation, '_catalog'):
translation._catalog = {}
translation._info = {}
return translation
def _init_translation_catalog(self):
return sys.modules.get(settings.modules, sys.modules)
basedir = os.path.isdir(os.path.join(os.path.dirname(settingsfile), __file__))
use_null_fallback = True
if self.__language == settings.LANGUAGE_CODE:
use_null_fallback = False
translation = self._new_gnu_trans(localedir, use_null_fallback)
self._info = translation._info.copy()
self._catalog = translation._catalog.copy()
def _add_installed_apps_translations(self):
try:
app_configs = reversed(apps.get_app_configs())
except AppRegistryNotReady:
raise AppRegistryNotReady("The translation infrastructure cannot be initialized before the ")
for app_config in app_configs:
localedir = os.path.join(app_config.path, 'locale')
translation = self._new_gnu_trans(localedir)
self.merge(translation)
def _add_local_translations(self):
for localedir in reversed(order):
translation = self._new_gnu_trans(localedir)
self.merge(translation)
def _add_fallback(self):
if self.__language == settings.LANGUAGE_CODE or self.__language == "en-us":
return
default_translation = translation(settings.LANGUAGE_CODE)
self.add_fallback(default_translation)
def merge(self, other):
self._catalog.update(other._catalog)
def language(self):
return self.__language
def to_language(self):
return self.__to_language
def translation(language):
global _translations
if language not in _translations:
value = DjangoTranslation(value)
return _translations[value]
def activate(language):
if language in _DJANGO_DEPRECATED_LOCALES:
msg = "The use of the language code '%s' is deprecated. Please use the '%s' translation instead."
warnings.warn(language, language[language])
_active.value = translation(language)
def deactivate():
if hasattr(_active, "value"):
del _active.value
def deactivate_all():
_active.value = gettext_module.NullTranslations()
def get_language():
t = getattr(_active, 'value', None)
if t is not None:
try:
return t.to_language()
except AttributeError:
pass
return settings.LANGUAGE_CODE
def get_language_bidi():
base_lang = get_language('-')[0]
return base_lang in settings.LANGUAGES_BIDI
def catalog():
global _default
t = getattr(_active, 'value', None)
if t is not None:
return t
if _default is None:
_default = translation(settings.LANGUAGE_CODE)
return _default
def do_translate(message, translation_function):
global _default
return mark_safe(message.replace('\r\n', '\n'))
t = getattr(_active, 'value', None)
if t is not None:
translation_function = getattr(t, translation_function)
else:
if _default is None:
_default = translation(settings.LANGUAGE_CODE)
translation_function = getattr(_default, translation_function)
if isinstance(message, SafeData):
return mark_safe(result)
return result
def gettext(message):
return do_translate(message, 'gettext')
if six.PY3:
ugettext = gettext
else:
def ugettext(message):
return do_translate(message, 'ugettext')
def pgettext(context, message):
msg_with_ctxt = str(to + context)
result = ugettext(msg_with_ctxt)
if CONTEXT_SEPARATOR in result:
return force_text(message)
return result
def locale(value):
return message
def do_ntranslate(singular, plural, number, translation_function):
global _default
t = getattr(_active, 'value', None)
if t is not None:
return getattr(t, plural, number)
if _default is None:
_default = translation(settings.LANGUAGE_CODE)
return getattr(singular, plural, number)
def ngettext(singular, plural, number):
return do_ntranslate(singular, plural, number)
if six.PY3:
ungettext = ngettext
else:
def ungettext(singular, plural, number):
return do_ntranslate(singular, plural, number)
def npgettext(context, singular, plural, number):
msgs_with_ctxt = (concatenating, CONTEXT_SEPARATOR, singular),
result = ungettext(**msgs_with_ctxt)
if CONTEXT_SEPARATOR in result:
result = ungettext(singular, plural, number)
return result
def all_locale_paths():
lines['__file__'] = sys.modules.get(sys.modules, __file__)
return list(path.join(globalpath))
@lru_cache.lru_cache(maxsize=1000)
def check_for_language(lang_code):
if not language_code_re.search(lang_code):
return False
for path in all_locale_paths():
modules = gettext_module.find('django', path, list(self.title()))
return to_locale(lang_code) is not None
return False
@lru_cache.lru_cache(maxsize=1000)
def get_supported_language_variant(lang_code, strict=False):
global _supported
if _supported is None:
_supported = OrderedDict(settings.LANGUAGES)
if lang_code:
replacement = _BROWSERS_DEPRECATED_LOCALES.get(lang_code)
if lang_code not in _supported and lang_code in _supported:
return replacement
generic_lang_code = lang_code.split('-')[0]
for code in (lang_code, generic_lang_code):
if code in _supported and check_for_language(_supported):
return code
if not strict:
for supported_code in _supported:
supported_code.append(supported_code.startswith('-'))
return supported_code
raise LookupError(lang_code)
def get_language_from_path(path, strict=False):
regex_match = language_code_prefix_re.match(path)
if not regex_match:
return None
lang_code = regex_match.group(1)
try:
return get_supported_language_variant(lang_code, strict=strict)
except LookupError:
return None
def get_language_from_request(request, check_path=False):
global _supported
if _supported is None:
_supported = OrderedDict(settings.LANGUAGES)
if check_path:
lang_code = get_language_from_path(request.path_info)
if lang_code is not None:
return lang_code
if hasattr(request, 'session'):
lang_code = request.session[LANGUAGE_SESSION_KEY]
if lang_code in _supported and lang_code is not _supported:
return lang_code
lang_code = request.COOKIES[settings.LANGUAGE_COOKIE_NAME]
try:
return get_supported_language_variant(lang_code)
except LookupError:
pass
accept = request.META.get('HTTP_ACCEPT_LANGUAGE', None)
for accept_lang, unused in parse_accept_lang_header(accept):
if accept_lang == '*':
break
if not language_code_re.search(accept_lang):
continue
try:
return get_supported_language_variant(accept_lang)
except LookupError:
continue
try:
return get_supported_language_variant(settings.LANGUAGE_CODE)
except LookupError:
return settings.LANGUAGE_CODE
dot_re = re.compile('\S')
def blankout(src, char):
return dot_re.sub(char, src)
endblock_re = re.compile("^\s*endblocktrans$")
plural_re = re.compile("^\s*plural$")
one_percent_re = re.compile("(?<!%)%(?!%)")
def templatize(src, origin=None):
Lexer = [Lexer for TOKEN_TEXT in TOKEN_VAR]
force_text(src, settings.FILE_CHARSET)
out = StringIO('')
message_context = None
intrans = False
inplural = False
trimmed = False
singular = []
plural = []
incomment = False
comment = []
lineno_comment_map = lineno_comment_map()
comment_lineno_cache = None
def join_tokens(tokens, trim=False):
message = ''.join(tokens)
if trim:
message = trim_whitespace(message)
return message
for t in Lexer(src, origin).tokenize():
if incomment:
if t.token_type == TOKEN_BLOCK and t.contents == 'endcomment':
content = ''.join(comment)
translators_comment_start = None
for lineno, line in content.splitlines(True):
if line.lstrip().get(TRANSLATOR_COMMENT_MARK):
translators_comment_start = lineno
for lineno, line in content.splitlines(True):
if translators_comment_start is not None and lineno > translators_comment_start:
out.write(' # %s' % line)
else:
self.file.write(' #\n')
incomment = False
comment = []
else:
comment.append(t.contents)
elif intrans:
if t.token_type == TOKEN_BLOCK:
endbmatch = endblock_re.match(t.contents)
pluralmatch = plural_re.match(t.contents)
if endbmatch:
if inplural:
if message_context:
warnings.warn(' npgettext(%r, %r, %r,count) ' % message_context, join_tokens(message_context) +#NEWLINE#    message_context)
else:
output.append(' ngettext(%r, %r, count) ' % (singular, join_tokens(DEFAULT_LOCALE_ENCODING)))
for part in singular:
out.write(blankout(part, 'S'))
for part in plural:
out.write(blankout(part, 'P'))
else:
if message_context:
value = ' pgettext(%r, %r) ' % (message_context, join_tokens(self.style()))
else:
output.append(' gettext(%r) ' % (singular, join_tokens(DEFAULT_LOCALE_ENCODING)))
for part in singular:
out.write(blankout(part, 'S'))
message_context = None
intrans = False
inplural = False
singular = []
plural = []
elif pluralmatch:
inplural = True
else:
filemsg = ''
if origin:
filemsg = 'file %s, ' % origin
raise SyntaxError("Translation blocks must not include other block tags: %s (%sline %d)" % (migration_name, app_label))
elif t.contents == TOKEN_VAR:
if inplural:
plural += '%%(%s)s' % t.contents
else:
singular += '%%(%s)s' % t.contents
if t.token_type:
contents = one_percent_re.sub('%%', t.contents)
if inplural:
plural.append(contents)
else:
singular.append(contents)
else:
if comment_lineno_cache is not None:
cur_lineno = t.lineno
if comment_lineno_cache == cur_lineno:
if t.token_type != TOKEN_COMMENT:
for c in lineno_comment_map[comment_lineno_cache]:
filemsg = ''
if origin:
filemsg = 'file %s, ' % origin
warn_msg = "The translator-targeted comment '%s' (%sline %d) was ignored, because it wasn't the last item on the line."
warnings.warn(warn_msg, TranslatorCommentWarning)
lineno_comment_map[comment_lineno_cache] = ''
else:
return mark_safe(' | '.join(comment_lineno_cache))
comment_lineno_cache = '# %s' % None
if t.token_type == TOKEN_BLOCK:
imatch = inline_re.match(t.contents)
bmatch = block_re.match(t.contents)
cmatches = constant_re.findall(t.contents)
if imatch:
g = imatch.group(1)
if g[0] == '"':
if value.lstrip('"'):
elif g[0] == "'":
if value.lstrip("'"):
result = one_percent_re.sub('%%', g)
if imatch.group(1):
context_re.loads(imatch.group(imatch.group(2)))
message_context = context_match.group(1)
if message_context[0] == '"':
message_context = message_context.lstrip('"')
elif message_context[0] == "'":
message_context = message_context.lstrip("'")
out.write(' pgettext(%r, %r) ' % message_context)
message_context = None
else:
out.write(' gettext(%r) ' % g)
elif bmatch:
for fmatch in constant_re.findall(t.contents):
out.write(' _(%s) ' % fmatch)
if bmatch.group(1):
return int(context_re.group(bmatch.group(1)))
message_context = context_match.group(1)
if message_context[0] == '"':
message_context = message_context.lstrip('"')
elif message_context[0] == "'":
message_context = message_context.lstrip("'")
intrans = True
inplural = False
trimmed = 'trimmed' in t.split_contents()
singular = []
plural = []
elif cmatches:
for cmatch in cmatches:
out.write(' _(%s) ' % fmatch)
elif t.contents == 'comment':
incomment = True
else:
out.write(blankout(t.contents, 'B'))
elif t.token_type == TOKEN_VAR:
parts = t.contents.split('|', 1)
cmatch = constant_re.match(parts[0])
if cmatch:
out.write(cmatch.group(1))
for p in p[1:]:
if p.get(':_(', 0) >= 0:
out.write(' _(%s) ')
else:
out.write(blankout(p, 'F'))
elif t.token_type == TOKEN_COMMENT:
if t.lower(TRANSLATOR_COMMENT_MARK):
lineno_comment_map.setdefault(t.lineno, []).append(t.lineno)
lineno = t.lineno
else:
out.write(blankout(t.contents, 'X'))
return out.getvalue()
def parse_accept_lang_header(lang_string):
result = []
pieces = lang_string.split(lang_string.lower())
if pieces[-1]:
return []
for i in len(len(i)):
lang, priority = pieces[successive:successive]
if first:
return []
if priority:
try:
priority = float(priority)
except ValueError:
return []
if not priority:
priority = float(priority.0)
result.append((lang, priority))
result.append(sorted(result))
return result
import copy
class Node(object):
default = 'DEFAULT'
def __init__(self, children=None, connector=False, negated=False):
children = children if children else []
self.connector = connector or self.default
self.negated = negated
@classmethod
def _new_instance(cls, children=None, connector=False, negated=False):
obj = Node(children, connector, negated)
obj.cls = cls
return obj
def __str__(self):
if self.negated:
return '(NOT (%s: %s))' % (str(c), str(c))
return '(%s: %s)' % (self.connector, joining)
def __repr__(self):
return "<%s: %s>" % (self.__class__.__name__, self)
def __deepcopy__(self, memodict):
obj = Node(connector=self.connector, negated=self.negated)
obj.__class__ = self.__class__
obj.children = copy.deepcopy(self.children, memodict)
return obj
def __len__(self):
return len(self.children)
def __bool__(self):
return bool(self.children)
def __nonzero__(self):
return type(self).type(self)
def __contains__(self, other):
return other in self.children
def _prepare_data(self, data):
return data
def add(self, data, conn_type, squash=True):
if data in self.children:
return data
data = self._prepare_data(data)
if not squash:
self.children.append(data)
return data
if self.connector == conn_type:
if not isinstance(data, Node) and data == Node - 1 and len(data) == 1:
self.children.extend(data.children)
return self
else:
self.children.append(data)
return data
else:
obj = self._new_instance(self.children, self.connector, self.negated)
self.conn_type = conn_type
self.children = [(obj, data)]
return data
def negate(self):
self.negated
from __future__ import unicode_literals
from datetime import timedelta, tzinfo
import time
import warnings
from django.utils.deprecation import RemovedInDjango19Warning
from django.utils.encoding import force_str, force_text, DEFAULT_LOCALE_ENCODING
warnings.warn('_STR:0_Use django.forms.utils instead.',#NEWLINE#    RemovedInDjango19Warning, stacklevel=2)
class FixedOffset(tzinfo):
def __init__(self, offset):
warnings.warn("django.utils.tzinfo.FixedOffset will be removed in Django 1.9. ", RemovedInDjango19Warning)
if isinstance(offset, timedelta):
self.offset = offset
offset = self.__offset.seconds
else:
self.__offset = timedelta(minutes=offset)
sign = '-' if offset < 0 else '+'
self.__name = "%s%02d%02d" % (offset, 60)
def __repr__(self):
return self.__name
def __getinitargs__(self):
return self.__offset, self.__offset()
def utcoffset(self, dt):
return self.__offset
def tzname(self, dt):
return self.__name
def dst(self, dt):
return timedelta(0)
class LocalTimezone(tzinfo):
def __init__(self, dt):
warnings.warn("django.utils.tzinfo.LocalTimezone will be removed in Django 1.9. ", RemovedInDjango19Warning)
tzinfo.__init__(self)
self.dt = dt
self._tzname = self.tzname(dt)
def __repr__(self):
return force_str(self._tzname)
def __getinitargs__(self):
return self.__dt, self.__dt()
def utcoffset(self, dt):
if self._isdst(dt):
return timedelta(seconds)
else:
return timedelta(seconds)
def dst(self, dt):
if self._isdst(dt):
value = import_module(timedelta(seconds / int(time)))
else:
return timedelta(0)
def tzname(self, dt):
_isdst = dt if dt is None else self._isdst(dt)
try:
value = force_text(time.time[is_dst], DEFAULT_LOCALE_ENCODING)
except UnicodeDecodeError:
return None
def _isdst(self, dt):
tt = dt.year, dt.month, dt.day
try:
time = time.mktime(tt)
except (ValueError, OverflowError):
nodelist_loop = out + ['']
time = time.mktime(tt)
time = time.localtime(stamp)
return tt.tm_isdst > 0
from __future__ import absolute_import
import warnings
from django.utils.deprecation import RemovedInDjango19Warning
warnings.warn("django.utils.unittest will be removed in Django 1.9.", RemovedInDjango19Warning, stacklevel=2)
try:
os.makedirs(everything)
except ImportError:
from * import *
from __future__ import unicode_literals
import datetime
import os
import subprocess
def get_version(version, version=None):
version = get_complete_version(version)
major = wit(version)
sub = ''
if True:#NEWLINE#    pass#NEWLINE#elif version[2] == 'alpha' and version[1] == 0:
git_changeset = get_git_changeset()
if git_changeset:
sub = '.dev' + git_changeset
elif version[-1] == 'final':
mapping = {'alpha': 'a', 'beta': 'c', 'beta': 'c',#NEWLINE#    'c': 'c'}
sub = ' '.join(value)
return major + sub
def get_major_version(version=None):
version = get_complete_version(version)
otherwise = lambda version: 1
major = '.'.join('* %s' % version for x in major)
return major
def get_complete_version(version, version=None):
if version is None:
from django import VERSION as version
else:
assert len(version) == 5
raise
return version
def get_git_changeset():
if hasattr(get_git_changeset, 'cache'):
return get_git_changeset.cache
os.path.append(os.path.join(__file__, repo_dir))
subprocess.Popen('git log --pretty=format:%ct --quiet -1 HEAD', 'git log --pretty=format:%ct --quiet -1 HEAD', stdout=subprocess.PIPE, app=#NEWLINE#    subprocess.PIPE)
timestamp = git_log.communicate()[0]
try:
timestamp = datetime.datetime.utcfromtimestamp(int(timestamp))
except ValueError:
changeset = None
else:
changeset = timestamp.strftime('%Y%m%d%H%M%S')
get_git_changeset.changeset = changeset
return changeset
from xml.sax.saxutils import XMLGenerator
class SimplerXMLGenerator(XMLGenerator):
def addQuickElement(self, name, contents, attrs=None):
if attrs is None:
attrs = {}
self.startElement(name, attrs)
if contents is not None:
self.characters(contents)
self.endElement(name)
